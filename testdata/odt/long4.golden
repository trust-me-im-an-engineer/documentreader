МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ федеральное государственное автономное образовательное учреждение высшего образования «САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ АЭРОКОСМИЧЕСКОГО ПРИБОРОСТРОЕНИЯ» (ГУАП) КАФЕДРА ВЫЧИСЛИТЕЛЬНЫХ СИСТЕМ И СЕТЕЙ Преподаватель старший преподаватель Н.А. Соловьева Отчет по лабораторной работе № 2 по дисциплине Алгоритмы с структуры данных на тему: «Линейные и циклические списки» Работу выполнил студент гр. 434 2 Иванов С.М. Санкт-Петербург 202 4 Алгоритм работы программы: Ввод длины последовательности и элементов: Пользователь вводит длину последовательности целых чисел n. Если длина последовательности меньше 1, программа выдает сообщение об ошибке. Если ввод корректен, пользователь вводит n уникальных целых чисел, которые добавляются в двусвязный список с помощью функции AddElem . Создание двусвязного списка: Первый элемент последовательности сохраняется как начальный узел списка. Остальные элементы добавляются в конец списка с помощью функции AddElem , которая проходит по узлам списка до самого конца и добавляет новый узел. Вывод списка: Функция PrintList выводит содержимое списка, начиная с его первого узла. Нахождение минимального элемента: Функция GetMin проходит по всем узлам списка и находит узел с минимальным значением. Этот узел возвращается в качестве результата. Извлечение последовательности от минимального элемента до начала списка: Функция GetAllPreviousSequense создает новый список, состоящий из всех элементов от минимального узла до первого узла исходного списка. Она идет по указателю prev (ссылке на предыдущий узел) от минимального узла к первому, добавляя каждый узел в новый список. Повторение программы: Пользователю предлагается ввести символ для продолжения работы программы. Если пользователь вводит 'r' или 'R', программа запускается снова, начиная с шага ввода длины последовательности. Код программы: #include <iostream> using namespace std; struct doublyLinkedNode { int elem; doublyLinkedNode *next; doublyLinkedNode *prev; }; void AddElem(doublyLinkedNode &list, int elem) { doublyLinkedNode *node = &list; while (node->next != nullptr ) { node = node->next; } doublyLinkedNode *newNode = new doublyLinkedNode; node->next = newNode; newNode->prev = node; newNode->elem = elem; newNode->next = nullptr ; } void PrintList(doublyLinkedNode &list) { doublyLinkedNode *node = &list; cout << node->elem << " " ; while (node->next != nullptr ) { node = node->next; cout << node->elem << " " ; } cout << endl; } doublyLinkedNode GetMin(doublyLinkedNode &list) { doublyLinkedNode *node = &list; int minElem = node->elem; doublyLinkedNode *minNode = &list; while (node->next != 0) { node = node->next; if (node->elem < minElem) { minElem = node->elem; minNode = node; } } return *minNode; } doublyLinkedNode GetAllPreviousSequense(doublyLinkedNode list) { doublyLinkedNode sequense = doublyLinkedNode{}; sequense.elem = list.elem; sequense.prev = nullptr ; doublyLinkedNode *node = &list; while (node->prev != nullptr ) { node = node->prev; AddElem(sequense, node->elem); } return sequense; } int main() { char quitOrRestart = 'r' ; do { int n; cout << "Enter sequense length: " ; cin >> n; if (n < 1) { cout << "Length must be greater than zero" << endl; continue ; } doublyLinkedNode list = doublyLinkedNode{}; list.prev = nullptr ; list.next = nullptr ; int a; cout << "Enter sequense of unique integers of " << n << " length: " ; cin >> list.elem; for ( int i = 0; i < n - 1; i++) { cin >> a; AddElem(list, a); } cout << endl << "Original sequense" << endl; PrintList(list); doublyLinkedNode minElem = GetMin(list); cout << endl << "Minimal element is " << minElem.elem << endl; doublyLinkedNode sequense = GetAllPreviousSequense(minElem); cout << endl << "Sequense from minimal element to first element of original sequense" << endl; PrintList(sequense); cout << endl << "Enter \"R\" to run again, or enter any other letter to quit programm: " ; cin >> quitOrRestart; } while (quitOrRestart == 'r' || quitOrRestart == 'R' ); return 0; } Пример выполнения программы: 